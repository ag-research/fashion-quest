% Generated by Sphinx.
\documentclass[letterpaper,10pt,english]{manual}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}


\title{Fashion Quest Documentation}
\date{September 20, 2009}
\release{Preview 2}
\author{Mike Cantelon}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex
\makemodindex
\newcommand\at{@}
\newcommand\lb{[}
\newcommand\rb{]}
\newcommand\PYGaz[1]{\textcolor[rgb]{0.00,0.63,0.00}{#1}}
\newcommand\PYGax[1]{\textcolor[rgb]{0.84,0.33,0.22}{\textbf{#1}}}
\newcommand\PYGay[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGar[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGas[1]{\textcolor[rgb]{0.25,0.44,0.63}{\textit{#1}}}
\newcommand\PYGap[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGaq[1]{\textcolor[rgb]{0.38,0.68,0.84}{#1}}
\newcommand\PYGav[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGaw[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGat[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGau[1]{\textcolor[rgb]{0.32,0.47,0.09}{#1}}
\newcommand\PYGaj[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGak[1]{\textcolor[rgb]{0.14,0.33,0.53}{#1}}
\newcommand\PYGah[1]{\textcolor[rgb]{0.00,0.13,0.44}{\textbf{#1}}}
\newcommand\PYGai[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGan[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGao[1]{\textcolor[rgb]{0.25,0.44,0.63}{\textbf{#1}}}
\newcommand\PYGal[1]{\colorbox[rgb]{1.00,0.94,0.94}{\textcolor[rgb]{0.25,0.50,0.56}{#1}}}
\newcommand\PYGam[1]{\textbf{#1}}
\newcommand\PYGab[1]{\textit{#1}}
\newcommand\PYGac[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaa[1]{\textcolor[rgb]{0.19,0.19,0.19}{#1}}
\newcommand\PYGaf[1]{\textcolor[rgb]{0.25,0.50,0.56}{\textit{#1}}}
\newcommand\PYGag[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGad[1]{\textcolor[rgb]{0.00,0.25,0.82}{#1}}
\newcommand\PYGae[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGaZ[1]{\textcolor[rgb]{0.02,0.16,0.45}{\textbf{#1}}}
\newcommand\PYGbf[1]{\textcolor[rgb]{0.44,0.63,0.82}{\textit{#1}}}
\newcommand\PYGaX[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGaY[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGbc[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGbb[1]{\textcolor[rgb]{0.78,0.36,0.04}{#1}}
\newcommand\PYGba[1]{\textcolor[rgb]{0.00,0.00,0.50}{\textbf{#1}}}
\newcommand\PYGaR[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGaS[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGaP[1]{\textcolor[rgb]{0.78,0.36,0.04}{\textbf{#1}}}
\newcommand\PYGaQ[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaV[1]{\textcolor[rgb]{0.05,0.52,0.71}{\textbf{#1}}}
\newcommand\PYGaW[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaT[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGaU[1]{\textcolor[rgb]{0.25,0.50,0.56}{\textit{#1}}}
\newcommand\PYGaJ[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand\PYGaK[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaH[1]{\textcolor[rgb]{0.50,0.00,0.50}{\textbf{#1}}}
\newcommand\PYGaI[1]{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{#1}}
\newcommand\PYGaN[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGaO[1]{\textcolor[rgb]{0.05,0.52,0.71}{\textbf{#1}}}
\newcommand\PYGaL[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand\PYGaM[1]{\textcolor[rgb]{0.73,0.73,0.73}{#1}}
\newcommand\PYGaB[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaC[1]{\textcolor[rgb]{0.33,0.33,0.33}{\textbf{#1}}}
\newcommand\PYGaA[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGaF[1]{\textcolor[rgb]{0.63,0.00,0.00}{#1}}
\newcommand\PYGaG[1]{\textcolor[rgb]{1.00,0.00,0.00}{#1}}
\newcommand\PYGaD[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGaE[1]{\textcolor[rgb]{0.25,0.50,0.56}{\textit{#1}}}
\newcommand\PYGbg[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGbe[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGbd[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand\PYGZat{@}
\newcommand\PYGZlb{[}
\newcommand\PYGZrb{]}

\begin{document}

\maketitle
\tableofcontents
\hypertarget{--doc-index}{}


\resetcurrentobjects
\hypertarget{--doc-introduction}{}

\chapter{Introduction}

Fashion Quest is an interactive fiction framework created to make \href{http://en.wikipedia.org/wiki/Interactive\_fiction}{text adventure games} about fashion because we love fashion and we love text adventure games. Fashion Quest requires \href{http://shoes.heroku.com/}{Shoes}, a cross-platform GUI framework created by \href{http://en.wikipedia.org/wiki/Why\_the\_lucky\_stiff/}{Why the Lucky Stiff}.

Text adventure games involve issuing tiny action plans, like \emph{go north} or \emph{fight the police}.

Games are created in Fashion Quest by defining game elements using YAML and bits of Ruby. The framework includes two demonstration games. The game ``Fashion Quest: Daydream'' is very small and designed to demonstrate non-player character features. It lives in the \emph{game} directory. The game ``Pirate Adventure Knockoff'' is a port of the 1978 text adventure \href{http://en.wikipedia.org/wiki/Pirate\_Adventure}{``Pirate Adventure''} by Scott and Alexis Adams and lives in the \emph{pirate\_adventure} directory.

To play either of these use Shoes to run \emph{run.rb} and select which youâ€™d like to play.

Thanks to Why the Lucky Stiff for creating Shoes and inspiring the creative use of computers!


\section{Interactive Fiction Frameworks}

Text adventure games are also known as interactive fiction (IF). Development of IF involves dealing with problems not inherent in many other realms of development, including parsing and simulation. Because of this a number of frameworks have been developed to deal with the IF domain. Major frameworks include Inform, Adrift, and TADS.

ADRIFT is one of the most user friendly of the frameworks. It allows games to be created using a GUI. It is not extensible, cross-platform, or open source, however.

Inform is one of the most elegant and established of the frameworks. It allows games to be developed either in natural language (Inform 7) or a specialize programming langague (Inform 6). It is extensible, cross-platform, open source, and supports automated game testing.

TADS.


\section{Design Goals of Fashion Quest}

Fashion Quest was created with the goal of being somewhere between ADRIFT and Inform in ease of use.

The design goals are as follows:
\begin{itemize}
\item {} 
\textbf{Minimalist}

Fashion Quest was designed to be lightweight and easy to learn. The simulated world is as simple as possible. Game command syntax is defined using patterns rather than natural language rules.

\item {} 
\textbf{Cross-platform}

By leveraging Shoes, Fashion Quest is able to provide a consistant user experience across whether being used in Windows, Mac OS, or Linux.

\item {} 
\textbf{Programmer-Friendly}

Fashion Quest development is done using the Ruby programming language rather than a domain-specific programming language. This lessen the framework learning curve for those who already known Ruby.

\item {} 
\textbf{Extensible}

Because Fashion Quest is open source, it is fully extensible. Default game engine behaviour can be overriden using monkey patching.

\end{itemize}

\resetcurrentobjects
\hypertarget{--doc-overview}{}

\chapter{Game Creation Overview}


\section{Directory Structure}

The \emph{docs} directory contains Fashion Quest developer documentation.

The \emph{engine} directory contains Fashion Quest application logic. Unless you want to play around with Fashion Quest's internals, you can ignore this directory.

The \emph{standard\_commands} directory contains standard game command definitions that can be shared between games.

Files pertaining used by specific games are put in \emph{game directories}. These directories can be put into the same parent directory as the above directories and can be named anything. When Fashion quest starts, it will look through all directories at this level to see which ones contain config.yaml files (in which game name, etc., are stored). If only one game directory is found, Fashion Quest will automatically select it. Otherwise, a game selector will be presented to the user.


\section{Game Configuration}

Basic game coniguration is done via a \emph{config.yaml} file. Each game directory must have one.

Game configuration options include game title, window width/height, whether the window should be resizable, startup message, and startup logic.

The basic look of a game can be tweaked using the startup logic. See the ``Pirate Adventure Knockoff'' demonstation game for an example.


\section{Game Elements}

GAME STATE?

The elements that make up a game include the player, locations, props, non-player characters, doors, commands, and transitions. All are defined using YAML with embedded Ruby.

Elements that the player may be able to carry are called \emph{game components}. These include props, characters, and doors. Usually only props can be carried, but some games might require a character or door be carryable.

Commands and transitions rely on Ruby logic to manipulate the other game elements. Commands are triggered by the user whereas transitions are triggered by sspecific game states.

\resetcurrentobjects
\hypertarget{--doc-components}{}

\chapter{Creating Game Components}


\section{Creating Locations}
\begin{itemize}
\item {} 
locations are put in the `rooms' subdirectory

\item {} 
exits can be directions ``north'' or arbitrary names ``stairs''

\end{itemize}


\section{Creating Doors}
\begin{itemize}
\item {} 
doors are put in the `doors' subdirectory

\item {} 
doors connect two or more locations

\item {} 
if a door connects more than two locations, when entering from one location you will end up at a random pick of the other locations

\end{itemize}


\section{Creating Props}
\begin{itemize}
\item {} 
props are put in the `props' subdirectory

\end{itemize}


\section{Creating Characters}
\begin{itemize}
\item {} 
characters are put in the `characters' subdirectory

\item {} 
characters are defined in YAML

\item {} 
any props a character will accept being given are indicated by the ``exchanges'' property

\end{itemize}


\section{Creating Commands}
\begin{itemize}
\item {} 
commands are defined in YAML

\item {} 
command files are put in the commands directory of the game's base directory

\item {} 
within the commands directory, commands can be placed in subdirectories if desired

\item {} 
commands are made up of syntax and logic

\item {} 
command syntax can have multiple forms
- each syntax form is composed of keywords and references
- keywords are static words: verbs
- references refer to ``things'': nouns
\begin{itemize}
\item {} 
types of references: prop, character, door, ad-hoc

\item {} 
prop, character, and door references can refer to any prop, character, or door in the same location as the player

\item {} 
if a prop, character, or door doesn't have the same location as the player, an error will be returned

\item {} 
ad-hoc references can refer to anything... there is no checking before passing an ad-hoc reference to command logic

\item {} 
in syntax form, references enclosed in less-than and greater-than symbols

\item {} 
examples:
- ``\textless{}prop\textgreater{}'' for unnamed prop reference
- ``\textless{}character\textgreater{}'' for unnamed prop reference
- ``\textless{}prop:some name\textgreater{}'' for a named prop reference
- ``\textless{}character:some other name\textgreater{}'' for a named character reference
- ``\textless{}anything\textgreater{}'' for an ad-hoc reference

\end{itemize}

\item {} 
command logic is written in Ruby
- variables are passed to the command logic
- references are passed as variables
\begin{itemize}
\item {} 
``\textless{}prop\textgreater{}'' unnamed prop reference passed as ``prop'' variable

\item {} 
``\textless{}character\textgreater{}'' unnamed character reference passed as ``character'' variable

\item {} 
``\textless{}prop:some name\textgreater{}'' named prop reference passed as ``arg{[}'some name'{]}'' variable

\item {} 
``\textless{}character:some other name\textgreater{}'' named character reference passed as ``arg{[}'some other name'{]}'' variable

\item {} 
``\textless{}anything\textgreater{}'' ad-hoc refrence passed as ``arg{[}anything{]}''

\end{itemize}
\begin{itemize}
\item {} 
``game'', ``player'', ``characters'', ``props'' variables allow interaction with game engine and game data
- ``game'' spec
- ``player'' spec
- ``characters'' spec
- ``props'' spec

\item {} 
example commands

\end{itemize}

\item {} 
commands can be shared between games
- if you want to share a command between games, put the command in the standard\_commands dirctory
- to include a shared command in a game, put an empty file in your game's command directory with the same filename
\begin{quote}

as the shared command
\end{quote}
\begin{itemize}
\item {} 
alternately, if you're not using Windows you can use symlinks

\end{itemize}

\end{itemize}


\section{Events}
\begin{itemize}
\item {} 
characters and props can have events associated with them

\item {} 
built-in character events are: on\_death, etc.

\item {} 
props can also have events

\item {} 
events can contain text and/or logic

\item {} 
to trgger events, simply add the logic into a command

\item {} \begin{description}
\item[for example, the get command could trigger an ``on\_get'' event in a prop:] \leavevmode
output \textless{}\textless{} game.event(props{[}prop{]}, `on\_get')

\end{description}

\item {} 
the above example would have the game check a certain prop for an on\_get response

\item {} \begin{description}
\item[an example response could be:] \leavevmode
@locations{[}'alcove'{]}.add\_to\_description(``There is a bookcase with a secret passage beyond.n''); ``There's a strange sound.n'';

\end{description}

\item {} 
the above example would add to a rooms description and give the player a hint that something in the game has changed

\end{itemize}


\section{Transitions}
\begin{itemize}
\item {} 
transitions allow manipulation of components to be triggered by game conditions, rather than user commands

\item {} 
this allows you to avoid having to add the same logic in multiple commands

\item {} 
transitions return output

\item {} 
if you want a transition to be silent, end it with the line ``''

\end{itemize}


\section{State}
\begin{itemize}
\item {} 
state can be used to keep track of global game conditions

\item {} 
state can be referred to or manipulated in transitions or commands

\item {} 
within transtions, use @state

\item {} 
example: @state{[}'tide'{]} = `in'

\item {} 
within commands, use game.state

\item {} 
example: game.state{[}'tide'{]} = `out'

\end{itemize}

\resetcurrentobjects
\hypertarget{--doc-fine_tuning}{}

\chapter{Fine-Tuning}


\section{Style}
\begin{itemize}
\item {} 
whenever possible, keep game-specific ``rules'' in transitions instead of commands

\item {} 
keeping game-specific logic out of commands allows them to be reused in different games

\end{itemize}


\section{Abbreviations, Synonyms, and Garbage Words}
\begin{itemize}
\item {} 
the command\_abbreviations.yaml file, in the game parsing path, allows a list of abbreviations for specific command instances to be defined

\item {} 
for example: ``n'' for ``go north''

\item {} 
in the above example, ``north'' was a parameter to the ``go'' command

\item {} 
in the case of abbreviations that don't need to specify a parameter, like ``i'' for ``inventory'', those should be included as a syntax of the command itself

\item {} 
the global\_synonyms.yaml file, in the game parsing path, allow a list of words that should be replaced with other words

\item {} 
for example: ``using'' for ``with''

\item {} 
in the above example, this synonym would elimiate the need to make the syntax ``attack \textless{}character\textgreater{} with \textless{}prop\textgreater{}'' also work when the player issues the command like ``attack bear using hat''

\item {} 
the garbage\_words.yaml file, found in the game's parsing path, allows certain words to be discarded from player input

\item {} 
these words should be words like ``the'' and ``a'' which have little semantic meaning

\item {} 
this makes specifying command syntax easier

\end{itemize}


\section{Testing}
\begin{itemize}
\item {} 
when saving and loading games be mindful that prop, etc., definitions get saved as well so your game changes may not be
reflected

\item {} 
use ``save walkthrough'' command to save your previous commands

\item {} 
use ``load walkthrough'' command to run through commands you've previously saved

\item {} 
these commands can be used for testing

\item {} 
walkthrough files are YAML, so easy to edit

\item {} 
COMPARE, TRANSCRIPT?

\item {} 
use the Shoes debugger... press alt-/ to see error messages

\item {} 
alert(`some message') is also handy to deduce the flow of logic

\item {} 
no need to check for prop or character locations in commands because command parser will return error if prop or character referenced doesn't exist or isn't located near player

\end{itemize}


\section{Naming}
\begin{quote}

noun      noun\_cap
\end{quote}

proper    Noun      Noun
plural    the nouns The nouns
general   a noun    A noun
countable water     Water


\chapter{Indices and tables}
\begin{itemize}
\item {} 
\emph{Index}

\item {} 
\emph{Module Index}

\end{itemize}


\renewcommand{\indexname}{Module Index}
\printmodindex
\renewcommand{\indexname}{Index}
\printindex
\end{document}
