% Generated by Sphinx.
\documentclass[letterpaper,10pt,english]{manual}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}


\title{Fashion Quest Documentation}
\date{September 26, 2009}
\release{Preview 2}
\author{Mike Cantelon}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex
\makemodindex
\newcommand\at{@}
\newcommand\lb{[}
\newcommand\rb{]}
\newcommand\PYGaz[1]{\textcolor[rgb]{0.00,0.63,0.00}{#1}}
\newcommand\PYGax[1]{\textcolor[rgb]{0.84,0.33,0.22}{\textbf{#1}}}
\newcommand\PYGay[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGar[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGas[1]{\textcolor[rgb]{0.25,0.44,0.63}{\textit{#1}}}
\newcommand\PYGap[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGaq[1]{\textcolor[rgb]{0.38,0.68,0.84}{#1}}
\newcommand\PYGav[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGaw[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGat[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGau[1]{\textcolor[rgb]{0.32,0.47,0.09}{#1}}
\newcommand\PYGaj[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGak[1]{\textcolor[rgb]{0.14,0.33,0.53}{#1}}
\newcommand\PYGah[1]{\textcolor[rgb]{0.00,0.13,0.44}{\textbf{#1}}}
\newcommand\PYGai[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGan[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGao[1]{\textcolor[rgb]{0.25,0.44,0.63}{\textbf{#1}}}
\newcommand\PYGal[1]{\colorbox[rgb]{1.00,0.94,0.94}{\textcolor[rgb]{0.25,0.50,0.56}{#1}}}
\newcommand\PYGam[1]{\textbf{#1}}
\newcommand\PYGab[1]{\textit{#1}}
\newcommand\PYGac[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaa[1]{\textcolor[rgb]{0.19,0.19,0.19}{#1}}
\newcommand\PYGaf[1]{\textcolor[rgb]{0.25,0.50,0.56}{\textit{#1}}}
\newcommand\PYGag[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGad[1]{\textcolor[rgb]{0.00,0.25,0.82}{#1}}
\newcommand\PYGae[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGaZ[1]{\textcolor[rgb]{0.02,0.16,0.45}{\textbf{#1}}}
\newcommand\PYGbf[1]{\textcolor[rgb]{0.44,0.63,0.82}{\textit{#1}}}
\newcommand\PYGaX[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGaY[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGbc[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGbb[1]{\textcolor[rgb]{0.78,0.36,0.04}{#1}}
\newcommand\PYGba[1]{\textcolor[rgb]{0.00,0.00,0.50}{\textbf{#1}}}
\newcommand\PYGaR[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGaS[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGaP[1]{\textcolor[rgb]{0.78,0.36,0.04}{\textbf{#1}}}
\newcommand\PYGaQ[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaV[1]{\textcolor[rgb]{0.05,0.52,0.71}{\textbf{#1}}}
\newcommand\PYGaW[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaT[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGaU[1]{\textcolor[rgb]{0.25,0.50,0.56}{\textit{#1}}}
\newcommand\PYGaJ[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand\PYGaK[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaH[1]{\textcolor[rgb]{0.50,0.00,0.50}{\textbf{#1}}}
\newcommand\PYGaI[1]{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{#1}}
\newcommand\PYGaN[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGaO[1]{\textcolor[rgb]{0.05,0.52,0.71}{\textbf{#1}}}
\newcommand\PYGaL[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand\PYGaM[1]{\textcolor[rgb]{0.73,0.73,0.73}{#1}}
\newcommand\PYGaB[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaC[1]{\textcolor[rgb]{0.33,0.33,0.33}{\textbf{#1}}}
\newcommand\PYGaA[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGaF[1]{\textcolor[rgb]{0.63,0.00,0.00}{#1}}
\newcommand\PYGaG[1]{\textcolor[rgb]{1.00,0.00,0.00}{#1}}
\newcommand\PYGaD[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGaE[1]{\textcolor[rgb]{0.25,0.50,0.56}{\textit{#1}}}
\newcommand\PYGbg[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGbe[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGbd[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand\PYGZat{@}
\newcommand\PYGZlb{[}
\newcommand\PYGZrb{]}

\begin{document}

\maketitle
\tableofcontents
\hypertarget{--doc-index}{}


\resetcurrentobjects
\hypertarget{--doc-introduction}{}

\chapter{Introduction}

Fashion Quest is an interactive fiction framework created to make \href{http://en.wikipedia.org/wiki/Interactive\_fiction}{text adventure games} about fashion because we love fashion and we love text adventure games. Fashion Quest is written in the Ruby programming language and requires \href{http://shoes.heroku.com/}{Shoes}, a cross-platform GUI framework created by \href{http://en.wikipedia.org/wiki/Why\_the\_lucky\_stiff/}{Why the Lucky Stiff}.

Games are created in Fashion Quest by defining game elements using YAML and bits of Ruby. The framework includes two demonstration games. The game ``Fashion Quest: Daydream'' is very small and designed to demonstrate non-player character features. It lives in the \emph{game} directory. The game ``Pirate Adventure Knockoff'' is a port of the 1978 text adventure \href{http://en.wikipedia.org/wiki/Pirate\_Adventure}{``Pirate Adventure''} by Scott and Alexis Adams and lives in the \emph{pirate\_adventure} directory.

To play either of these use Shoes to run \emph{run.rb} and select which youâ€™d like to play.

Thanks to Why the Lucky Stiff for creating Shoes and inspiring the creative use of computers!


\section{Why Use a Framework?}

Development of interactive fiction (IF) involves dealing with problems not inherent in many other realms of development, including parsing and game world simulation. Because of this a number of frameworks have been developed to deal with the IF domain.

Fashion Quest is a relative newcomer. Established frameworks include \emph{Inform}, \emph{Adrift}, and \emph{TADS}.

\href{http://www.adrift.org.uk/}{ADRIFT} is one of the most user friendly of the frameworks. It allows games to be created using a GUI. It is not, however, extensible, cross-platform, or open source.

\href{http://www.inform-fiction.org/I7/Welcome.html}{Inform} is one of the most elegant and established of the frameworks. It allows games to be developed either in natural language (Inform 7) or a specialize programming langague (Inform 6). It is extensible, cross-platform, open source, and supports automated game testing.

\href{http://www.tads.org/}{TADS} is reputedly more powerful than Inform, but has a fairly steep learning curve.

When evaluating IF frameworks, an interesting site is \href{http://www.firthworks.com/roger/cloak/index.html}{Cloak of Darkness}. This site links to implementations of the same simple interactive fiction game created using twenty different IF frameworks.


\section{Design Goals of Fashion Quest}

Fashion Quest was created with the goal of being somewhere between ADRIFT and Inform in ease of use.

The design goals are as follows:
\begin{itemize}
\item {} 
\textbf{Minimalist}

Fashion Quest was designed to be lightweight and easy to learn. The simulated world is as simple as possible. Game command syntax is defined using patterns rather than natural language rules.

\item {} 
\textbf{Cross-platform}

By leveraging Shoes, Fashion Quest is able to provide a consistant user experience across whether being used in Windows, Mac OS, or Linux.

\item {} 
\textbf{Programmer-Friendly}

Fashion Quest development is done using the Ruby programming language rather than a domain-specific programming language. This lessens the framework learning curve as there are many resources for those wishing to learn Ruby (and those who already know Ruby get a head start).

\item {} 
\textbf{Extensible}

Because Fashion Quest is open source, it is fully extensible. Default game engine behaviour can be overriden using monkey patching.

\end{itemize}

\resetcurrentobjects
\hypertarget{--doc-overview}{}

\chapter{Overview}


\section{Directory Structure}

The \emph{doc} directory contains Fashion Quest developer documentation.

The \emph{engine} directory contains Fashion Quest application logic. Unless you want to play around with Fashion Quest's internals, you can ignore this directory.

The \emph{standard\_commands} directory contains standard game command definitions that can be shared between games.

Files pertaining used by specific games are put in \emph{game directories}. These directories can be put into the same parent directory as the above directories and can be named anything. When Fashion quest starts, it will look through all directories at this level to see which ones contain config.yaml files (in which game name, etc., are stored). If only one game directory is found, Fashion Quest will automatically select it. Otherwise, a game selector will be presented to the user.


\section{Game Elements}

The elements that make up a game include the player, locations, props, non-player characters, doors, game state, commands, and transitions. All are defined using YAML with embedded Ruby.

Elements that the player may be able to carry are called \emph{game components}. These include props, characters, and doors. Usually only props can be carried, but some games might require a character or door be carryable.

Game state allows ad-hoc game world conditions to be stored. In the demonstration game ``Pirate Adventure Knockoff'', for example, game state is used to record whether or not the tide is in.

Commands and transitions rely on Ruby logic to manipulate the other game elements. Commands are triggered by the user whereas transitions are triggered by the conditions of other game elements.


\section{Game Directory Structure}

The game directory contains a number of folders and files in which game configuration live.
\begin{itemize}
\item {} 
\textbf{Basic Configuration}

Each game directory must contain a \emph{config.yaml} file. This file contains high-level configuration parameters such as game title, window width/height, whether the game window should be resizable, startup message, and startup logic.

The basic look of a game can be tweaked using the startup logic. See the ``Pirate Adventure Knockoff'' demonstation game for an example.

\item {} 
\textbf{Transitions}

A game directory may contain a \emph{transitions.yaml} file. This file defines any transitions.

\item {} 
\textbf{Characters}

A game directory may contain a \emph{characters} directory in which files that define non-player characters are kept.

\item {} 
\textbf{Commands}

A game directory requires a \emph{commands} directory in which files that define commands, or reference standard commands, are kept.

\item {} 
\textbf{Doors}

A game directory may contain a \emph{doors} directory in which a file that defines doors is kept.

\item {} 
\textbf{Locations}

A game directory requires a \emph{locations} directory in which files that define locations are kept.

\item {} 
\textbf{Parsing}

A game directory may contain a \emph{parsing} directorry in which files related to the fine-tuning of command parsing are kept.

\item {} 
\textbf{Player}

A game directory requires a \emph{player} directory in which a file that defines the player's attributes is kept.

\item {} 
\textbf{Props}

A game directory requires a \emph{props} directory in which a file that defines game props is kept.

\end{itemize}


\section{Built-in Commands}

There are a number of built-in commands that don't appear in the command directories. These are: \emph{restart}, \emph{clear}, \emph{load}, \emph{save}, \emph{load walkthrough}, \emph{save walkthrough}, save \emph{transcript}, and \emph{compare to transcript}.

\emph{restart} restarts the game. \emph{clear} clears the command output. \emph{load} and \emph{save} allow the user to load or save their game progress to a file.

The other built-in commands are developer-oriented and discussed in the testing section.

\resetcurrentobjects
\hypertarget{--doc-elements}{}

\chapter{Game World Elements}

Game world elements are defined using \href{http://www.yaml.org/}{YAML}, a human-readable standard used to describe data structures using text. Each game component must have a globally unique identifier.


\section{Locations}

Locations are places a player can visit during a game.

Each location is defined in its own YAML file within the `locations' subdirectory of the game directory.

The example below, from the ``Pirate Adventure Knockoff'' demonstration game, defines a location with two exits: an exit to the north and an open window. The unique indentifier of the location is \emph{alcove}.

\begin{Verbatim}[commandchars=@\[\]]
alcove:
  exits:
    down:
      destination: apartment
    window:
      destination: ledge

  description: @textbar[]
    I'm in an alcove. There is an open window. There is a bookcase full of books.
\end{Verbatim}


\section{Doors}

Doors allow two or more locations to be connected. If a door connects more than two locations, when entering from one location you will end up at a random pick of the other locations.

Doors are defined in a file called \emph{doors.yaml} within the \emph{doors} subdirectory of the game directory.

The example below, from the ``Fashion Quest: Daydream'' demonstration game, defines a door that allows the player to travel between two locations. The door is locked by default, but may be opened using the \emph{brass key} prop. The unique indentifier of the door is \emph{door}.

\begin{Verbatim}[commandchars=@\[\]]
---
door:
  name: door
  description: The door is made of dark-brown wood.
  locations:
  - hallway
  - bedroom
  traits:
    opened: false
    opens@_with:
    - brass key
\end{Verbatim}


\section{Props}

Props are items that players can interact with in the game. They may be portable items, such as a pack of cigarettes, or items that can't be carried, such as a dresser.

Props are defined in a file called \emph{props.yaml} within the \emph{props} subdirectory of the game directory.

The example below, from the ``Fashion Quest: Daydream'' demonstration game, defines a dresser located in a location with the unique identifier \emph{bedroom}. The dresser can be opened by the player and contains another prop, a pack of \emph{smokes}.

\begin{Verbatim}[commandchars=@\[\]]
dresser:
  description: The dresser looks like it has seen better days.
  location: bedroom
  traits:
    opened: false
    portable: false
    contains:
      - prop: smokes
\end{Verbatim}


\section{Characters}

Characters are beings that players can interact with in the game.

Each character is defined in its own YAML file within the `characters' subdirectory of the game directory.

The example below, from the ``Pirate Adventure Knockoff'' demonstration game, defines a character located in a location with the unique identifier \emph{shack}. The pirate will accept the \emph{rum} prop if the player gives it to him.

\begin{Verbatim}[commandchars=@\[\]]
--- 
pirate: 
  description: The pirate has a wicked look.
  location: shack
  exchanges:
    rum: true
\end{Verbatim}


\section{State}

Game state is used to keep track of game conditions other than the state of other game elements. State can be referenced, or set, from logic within commands, transitions, and events.

One example from the \emph{Pirate Adventure Knockoff} demonstration is tide state. Tide state is changed using transitions that set state using simple logic, such as the line shown below.

\begin{Verbatim}[commandchars=@\[\]]
@PYGaS[@at[]state]@PYGbd[@lb[]]@PYGbc['tide']@PYGbd[@rb[]] @PYGbd[=] @PYGbc['in']
\end{Verbatim}

\resetcurrentobjects
\hypertarget{--doc-manipulation}{}

\chapter{Game World Manipulation}

Game components are defined using \href{http://www.yaml.org/}{YAML}, a human-readable standard used to describe data structures using text. Each game component must have a globally unique identifier.


\section{Commands}

Each command is defined in its own YAML file within the `commands' subdirectory of the game directory. If a command file within this directory exists, but is empty, the game engine will look for a command with the same filename in the \emph{standard\_commands} directory.

\begin{notice}{note}{Note:}
Symbolic links can also be used, instead of empty command files, to point to standard commands but Windows doesn't support symbolic links so the game won't be cross platform.
\end{notice}

The example below, from the ``Pirate Adventure Knockoff'' demonstration game, defines a command that enables the player to wake up the pirate character. If the character's \emph{asleep} trait is \emph{true} the \emph{asleep} trait will be changed to \emph{false} if the player enters the command \emph{wake pirate}.

\begin{Verbatim}[commandchars=@\[\]]
---
syntax:
- "wake @textless[]character@textgreater[]"
- "wake up @textless[]character@textgreater[]"

logic: @textbar[]

  output = ''

  if character.traits@PYGZlb[]'asleep'@PYGZrb[] == true
    character.traits@PYGZlb[]'asleep'@PYGZrb[] = false
  else
    output @textless[]@textless[] "You can't wake up what is not asleep.\n"
  end

  output
\end{Verbatim}

Commands are made up of syntax and logic.

TIP: Keep the idea of reusing commands between games in mind when creating commands. If logic is game-specific, try to use transitions instead of commands to implement the logic.


\subsection{Syntax Forms}

Command syntax can have multiple forms. For example, a command that allows the player to pick up a prop could have the form \emph{get \textless{}prop\textgreater{}} or \emph{take \textless{}prop\textgreater{}}.

Each syntax form is composed of keywords and parameters. Parameters are usually references to game elements. With the case of the above example \emph{get} and \emph{take} are the keywords and \emph{\textless{}prop\textgreater{}} is the reference parameter.

Keywords are static words identifying an action: verbs. References refer to ``things'': nouns.

Four types of parameters can be used: prop references, character references, door references, and text.

Prop, character, and door references can refer to any prop, character, or door in the same location as the player. If a prop, character, or door is referenced, but doesn't have the same location as the player, an error will be output.

When defining syntax forms, parameters are enclosed in less-than and greater-than symbols. A reference paramter can be given the same name as its type or can be given a name. A syntax form containing the prop reference parameter \emph{\textless{}prop\textgreater{}} would pass to the command a reference named \emph{prop}. A syntax form \emph{\textless{}prop:thing\textgreater{}} would pass to the command a reference named \emph{arg{[}'thing'{]}}.

Text parameters are always named. A syntax form containing the ad-hoc reference \emph{\textless{}colour\textgreater{}} would pass to the command the variable \emph{arg{[}'color'{]}}.

Examples:
- ``\textless{}prop\textgreater{}'' for unnamed prop reference
- ``\textless{}character\textgreater{}'' for unnamed prop reference
- ``\textless{}prop:some name\textgreater{}'' for a named prop reference
- ``\textless{}character:some other name\textgreater{}'' for a named character reference
- ``\textless{}anything\textgreater{}'' for an ad-hoc reference


\subsection{Logic}

Command logic is written in Ruby. References to props, characters, or doors can be passed in as specified by syntax forms.

In addition to data passed in via syntax forms, game elements can also be arbitrarily accessed.

\emph{@game} provides access to game properties and methods.

\emph{@player} provides access to player properties and methods.

\emph{@props} provides access to the properties and methods of individual props.

\emph{@characters} provides access to the properties and methods of individual characters.

The best way to understand how commands work is to check out the commands in the \emph{standard\_commands} directory.


\section{Events}

Events enable Ruby logic to be triggered by happenings in the game world. Characters, props, and doors can all have event outcome associated with them.

For example, the \emph{cat} character in the ``Fashion Quest: Daydream'' demonstration game responds to two events: \emph{on\_attack} (when the cat is attacked) and \emph{on\_death} (when the cat is killed).

\begin{Verbatim}[commandchars=@\[\]]
--- 
cat: 
  mobility: 100
  strength: 1
  description: The cat is small and agile.
  hp: 2
  aggression: 5
  location: bedroom
  events:
    on@_attack:
    - "The cat yowls as he leaps at you.\n"
    on@_death:
    - "The cat shrieks as it crumples to the ground.\n"
\end{Verbatim}

Commands can be used to trigger events. For example, the standard get command triggers the \emph{on\_get} event on a prop (and collects event output into the variable \emph{on\_get\_output} by including the following line:

\begin{Verbatim}[commandchars=@\[\]]
on@_get@_output @PYGbd[=] @PYGaS[@at[]game]@PYGbd[.]event(prop, @PYGbc['on@_get'])
\end{Verbatim}

The ``Pirate Adventure Knockoff'' demonstration game uses the \emph{on\_get} event of the \emph{book} prop to change the description of a room, revealing a secret passage, and return a hint to the player that something has changed.

\begin{Verbatim}[commandchars=@\[\]]
book:
  description: The book is large and blood-soaked.
  location: alcove
  events:
    on@_get: @textbar[]
      if not (@PYGZat[]locations@PYGZlb[]'alcove'@PYGZrb[].has@_exit('passage'))
        @PYGZat[]props@PYGZlb[]'book'@PYGZrb[].traits@PYGZlb[]'visible'@PYGZrb[] = true
        @PYGZat[]locations@PYGZlb[]'alcove'@PYGZrb[].add@_to@_description("The bookcase is open to reveal a secret passage beyond.\n")
        @PYGZat[]locations@PYGZlb[]'alcove'@PYGZrb[].set@_exit('passage', 'passageway')
        "There's a strange sound.\n";
      end
\end{Verbatim}

If event YAML is set to be a list of event outcomes then an outcome will be randomly selected from the list when the event is triggered, as an example shows below.

\begin{Verbatim}[commandchars=@\[\]]
on@_discuss:
@PYGbd[-] @PYGaW["]@PYGaW[The deadbeat squints at you and shuffles his feet before answering.]@PYGao[\n]@PYGaW["]
@PYGbd[-] @PYGaW["]@PYGaW[The deadbeat tilts his head sceptically before answering.]@PYGao[\n]@PYGaW["]
\end{Verbatim}


\section{Transitions}

Transitions enable Ruby logic to be triggered by happenings in the game world. Transitions are more versitile than events: any game condition(s) can be used to trigger the manipulation of any game element(s).

To add transitions to a game, create the file \emph{transitions.yaml} in the appropriate game directory. Transitions are made up of one or more triggering conditions and one or more outcomes.

The example transition below, containing conditions and outcomes extracted from the ``Pirate Adventure Knockoff'' demonstration game, shows a transition that makes a pet leave if neither his master nor food are present.

\begin{Verbatim}[commandchars=@\[\]]
---
conditions:

  ?
    - @PYGZat[]player.location == @PYGZat[]characters@PYGZlb[]'parrot'@PYGZrb[].location
        @&@& @PYGZat[]characters@PYGZlb[]'parrot'@PYGZrb[].location != @PYGZat[]characters@PYGZlb[]'pirate'@PYGZrb[].location
        @&@& @PYGZat[]characters@PYGZlb[]'parrot'@PYGZrb[].location != @PYGZat[]props@PYGZlb[]'crackers'@PYGZrb[].location
  :
    - parrot@_flies@_off

outcomes:

  parrot@_flies@_off: @textbar[]
    if @PYGZat[]props@PYGZlb[]'crackers'@PYGZrb[].location != 'player'
      @PYGZat[]characters@PYGZlb[]'parrot'@PYGZrb[].location = @PYGZat[]props@PYGZlb[]'crackers'@PYGZrb[].location
      "The parrot flies off looking very unhappy...\n"
    end
\end{Verbatim}

If you want a transition output to not return output, end it with a line containing only \emph{``''}.

\resetcurrentobjects
\hypertarget{--doc-fine_tuning}{}

\chapter{Fine-Tuning}


\section{Parsing}

Fashion Quest includes employs a crude, case-insensitive, parsing mechanism that converts player input into ``lexemes'': text elements (single words or game element identifiers such as ``hat'' or ``blue hat'') that can be compared to command syntax forms.

Here's the basic flow of parsing:
\begin{enumerate}
\item {} 
Abbreviated commands are expanded

\item {} 
Input is broken into lexemes (single words or game element indentiers)

\item {} 
Lexemes that match synonyms are replaced

\item {} 
Lexemes that match garbage words are deleted

\item {} 
Lexemes that are aliases to game element IDs are resolved

\end{enumerate}


\subsection{Abbreviated Commands}

Abbreviated commands reduce the amount of typing the user must do. One popular convention in interactive fiction is allowing a user simply to enter the first letter of the direction (s)he'd like to go in: \emph{n} for \emph{go north}, for example.

The \emph{command\_abbreviations.yaml} file, in the \emph{parsing} subdirectory of the game directory, allows a list of abbreviations for specific command instances to be defined using YAML. The file from the ``Pirate Adventure Knockoff'' demonstration game is shown below.

\begin{Verbatim}[commandchars=@\[\]]
---
n: "go north"
s: "go south"
e: "go east"
w: "go west"
u: "go up"
d: "go down"
\end{Verbatim}

\begin{notice}{note}{Note:}
The \emph{command\_abbreviations.yaml} file isn't the only place command abbreviation can be specified. Command syntax forms that don't contain parameters, like those of the \emph{inventory} command, allow abbreviations to be stored in the command's syntax forms (\emph{i} for inventory, for example).
\end{notice}


\subsection{Synonyms}
\begin{itemize}
\item {} 
the global\_synonyms.yaml file, in the game parsing path, allow a list of words that should be replaced with other words

\item {} 
for example: ``using'' for ``with''

\item {} 
in the above example, this synonym would elimiate the need to make the syntax ``attack \textless{}character\textgreater{} with \textless{}prop\textgreater{}'' also work when the player issues the command like ``attack bear using hat''

\end{itemize}


\subsection{Garbage Words}
\begin{itemize}
\item {} 
the garbage\_words.yaml file, found in the game's parsing path, allows certain words to be discarded from player input

\item {} 
these words should be words like ``the'' and ``a'' which have little semantic meaning

\item {} 
this makes specifying command syntax easier

\end{itemize}


\subsection{Aliases}

Explain about aliases.


\section{Testing}

Testing interactive fiction games can be tedious. To make testing easier Fashion Quest provides a couple of simple tools in the form of built-in commands.

In addition to the built-in commands, the Shoes \emph{alert} function is handy for confirming logic is being executed. \emph{alert(`Hello}){}` will, for example, pop up a dialog box with the word ``hello''.

When there are syntax errors in game logic, or other errors that stop game execution, you can often get useful clues by pressing Alt-/ to view the Shoes debugging console.


\subsection{Walkthroughs}

When a player loads or saves a game, via the built-in \emph{load} and \emph{save} commands, all game element definitions are included in the game save. Because of this, these commands aren't very useful for testing.

Walkthroughs, on the other hand, can save a sequence of commands needed to arrive at a certain point in a game. This makes them useful for functional testing. Walkthrough files are simply a YAML list of commands.

To create a walkthrough, simply start you game and play it until the point at which you'd like your walkthrough to end. Entering the command \emph{save walkthrough} will then allow you to save the walkthrough. When you wish to use a walkthrough, start or restart Fashion Quest and enter the command \emph{load walkthrough}.

An example walkthrough is provides for the ``Pirate Adventure Knockoff'' demonstration game. It lives in the \emph{pirate\_adventure} directory and is named \emph{complete\_walkthrough}. It cycles through all the commands needed to win the game. Once the walkthrough has loaded, enter the command \emph{score} and the win will be confirmed.


\subsection{Transcripts}

While walkthroughs are good for confirming nothing is broken, transcripts provide a way to confirm no output in a game has changed.

The built-in command \emph{save transcript} will save the game output to a file. You can then make changes to your game, enter the commands needed to arrive at the point in the game where you originally saved the transcript, and use the built-in command \emph{compare transcript} to compare the game output to the original transcript.


\section{Naming}
\begin{quote}

noun      noun\_cap
\end{quote}

proper    Noun      Noun
plural    the nouns The nouns
general   a noun    A noun
countable water     Water


\chapter{Indices and tables}
\begin{itemize}
\item {} 
\emph{Index}

\item {} 
\emph{Module Index}

\end{itemize}


\renewcommand{\indexname}{Module Index}
\printmodindex
\renewcommand{\indexname}{Index}
\printindex
\end{document}
